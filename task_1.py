"""
Задание 1.
Реализуйте кодирование строки "по Хаффману".
У вас два пути:
1) тема идет тяжело? тогда вы можете, опираясь на пример с урока, сделать свою версию алгоритма
Разрешается и приветствуется изменение имен переменных, выбор других коллекций, различные изменения
и оптимизации.
КОПИПАСТ ПРИМЕРА ПРИНИМАТЬСЯ НЕ БУДЕТ!
2) тема понятна? постарайтесь сделать свою реализацию.
Вы можете реализовать задачу, например, через ООП или предложить иной подход к решению.

ВНИМАНИЕ: примеры заданий будут размещены в последний день сдачи.
Но постарайтесь обойтись без них.


Честно сказать, этот урок действительно сложный, сам бы я не додумался. Интернет помог.
Решение понравилось с очередьми с приоритетами, кучей и именованным кортежем, на мой взгляд оно довольно логичное.
"""


import heapq  # модуль для работы с кучей
from collections import Counter, namedtuple


class Node(namedtuple("Node", "left_branch, right_branch")):
    # класс для ветвей дерева - узел и потомки (именованный кортеж)
    def go_tree(self, code_str, code_symbol):
        # метод обхода дерева - левая ветвь, добавляем к коду 0
        self.left_branch.go_tree(code_str, code_symbol + "0")
        # правая ветвь, добавляем к коду 1
        self.right_branch.go_tree(code_str, code_symbol + "1")


class Leaf(namedtuple("Leaf", "char")):
    # класс для листьев дерева, потомков нет
    def go_tree(self, code_str, code_symbol):
        # потомков у листа нет, поэтому значением листа будет код, собранный при обходе дерева до него,
        # но если строка будет всего 1 элемент, ей будет нужно назначить значение 0
        code_str[self.char] = code_symbol or "0"


def huffman_encode(some_string):
    str_list = []
    for char, frequency in Counter(some_string).items():
        # в цикле перебираем отсортированный по частоте словарь
        str_list.append((frequency, len(str_list), Leaf(char)))
        # список из частот, счётчика и классов листьев из самих символов
    heapq.heapify(str_list)  # сделаем очередь с приоритетами из списка именованных кортежей
    count = len(str_list)  # длина очереди
    while len(str_list) > 1:  # пока в очереди более 1 элемента
        freq_left, _count1, left = heapq.heappop(str_list)
        # вытаскиваем элемент с минимальной частотой - это будет левый узел
        freq_right, _count2, right = heapq.heappop(str_list)
        # вытаскиваем следующий элемент с минимальной частотой - это будет правый узел
        heapq.heappush(str_list, (freq_left + freq_right, count, Node(left, right)))
        # рекурсивно помещаем в очередь новый узел с потомками,
        # у которого частота равна сумме частот вытащенных элементов
        count += 1  # увеличиваем значение счетчика при добавлении нового элемента дерева
    code_dict = {}
    if str_list:
        [(_freq, _count, root)] = str_list
        # если введена пустая строка, то очередь будет пустая и обходить нечего
        # в очереди 1 элемент и это корень дерева
        root.go_tree(code_dict, "")
        # обходим дерево от корня и заполняем словарь для получения кодирования Хаффмана
    return code_dict  # возвращаем итоговый словарь - символ: код


def get_code_string():
    my_str = input('Введите строку: ')  # принимается длина до 10**4
    code_dict = huffman_encode(my_str)  # словарь - символ: код
    print(code_dict)
    for char in code_dict:
        print(code_dict[char], end=' ')
    # выводим строку, состоящую из кодов, посимвольно через пробел


if __name__ == "__main__":
    get_code_string()
